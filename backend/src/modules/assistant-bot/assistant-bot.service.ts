import { Injectable, Logger, OnModuleInit } from "@nestjs/common";
import { ConfigService } from "@nestjs/config";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import axios from "axios";

import { User } from "../../database/entities/user.entity";

export interface TelegramUpdate {
  update_id: number;
  message?: {
    message_id: number;
    from: {
      id: number;
      is_bot: boolean;
      first_name: string;
      last_name?: string;
      username?: string;
      language_code?: string;
    };
    chat: {
      id: number;
      first_name: string;
      last_name?: string;
      username?: string;
      type: string;
    };
    date: number;
    text?: string;
  };
}

/**
 * –°–µ—Ä–≤–∏—Å –¥–ª—è –±–æ—Ç–∞-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞ BotManager
 * –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—ã /start –∏ –ø–æ–º–æ–≥–∞–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º —Å —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–µ–π
 *
 * OnModuleInit - –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç webhook –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –º–æ–¥—É–ª—è
 */
@Injectable()
export class AssistantBotService implements OnModuleInit {
  private readonly logger = new Logger(AssistantBotService.name);
  private readonly botToken: string;
  private readonly telegramApiUrl: string;

  constructor(
    private configService: ConfigService,
    @InjectRepository(User)
    private userRepository: Repository<User>
  ) {
    this.botToken = this.configService.get<string>("app.telegramBotToken");
    this.telegramApiUrl = this.configService.get<string>(
      "TELEGRAM_BOT_API_URL",
      "https://api.telegram.org/bot"
    );

    if (!this.botToken) {
      this.logger.warn(
        "TELEGRAM_BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –ë–æ—Ç-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –±—É–¥–µ—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω."
      );
    }
  }

  /**
   * –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è NestJS –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –º–æ–¥—É–ª—è
   * –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç webhook –¥–ª—è –±–æ—Ç–∞
   */
  async onModuleInit() {
    if (!this.botToken) {
      this.logger.warn("–ü—Ä–æ–ø—É—Å–∫ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ webhook - —Ç–æ–∫–µ–Ω –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω");
      return;
    }

    try {
      this.logger.log("ü§ñ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞ webhook –±–æ—Ç–∞-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞...");
      await this.setupWebhook();
      this.logger.log("üéâ –ë–æ—Ç-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!");
    } catch (error) {
      this.logger.warn(`‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å webhook: ${error.message}`);
      this.logger.warn("üìù Webhook –º–æ–∂–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤—Ä—É—á–Ω—É—é —á–µ—Ä–µ–∑ API");
    }
  }

  private getBotApiUrl(): string {
    return `${this.telegramApiUrl}${this.botToken}`;
  }

  async handleUpdate(update: TelegramUpdate): Promise<void> {
    try {
      this.logger.log(`üì© –ü–æ–ª—É—á–µ–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ: ${JSON.stringify(update)}`);

      if (update.message?.text) {
        await this.handleMessage(update.message);
      }
    } catch (error) {
      this.logger.error(
        `‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è: ${error.message}`,
        error.stack
      );
    }
  }

  private async handleMessage(
    message: TelegramUpdate["message"]
  ): Promise<void> {
    if (!message) return;

    const { text, from, chat } = message;
    const telegramId = from.id.toString();

    this.logger.log(`üì® –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç ${telegramId}: ${text}`);

    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–æ–º–∞–Ω–¥—É /start
    if (text === "/start") {
      this.logger.log(`üöÄ –ö–æ–º–∞–Ω–¥–∞ /start –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${telegramId}`);
      await this.handleStartCommand(telegramId, from, chat);
    } else {
      this.logger.log(`‚ÑπÔ∏è –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞: ${text}`);
    }
  }

  private async handleStartCommand(
    telegramId: string,
    from: TelegramUpdate["message"]["from"],
    chat: TelegramUpdate["message"]["chat"]
  ): Promise<void> {
    try {
      this.logger.log(`üîç –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å telegramId: ${telegramId}`);

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
      const existingUser = await this.userRepository.findOne({
        where: { telegramId },
      });

      if (existingUser) {
        // –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω
        this.logger.log(`‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–π–¥–µ–Ω: ${existingUser.id}`);
        await this.sendWelcomeBackMessage(chat.id, from.first_name);
      } else {
        // –ù–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –ø–æ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
        this.logger.log(`üìù –ù–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å, –æ—Ç–ø—Ä–∞–≤–∫–∞ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π`);
        await this.sendRegistrationInstructions(
          chat.id,
          from.first_name,
          telegramId
        );
      }
    } catch (error) {
      this.logger.error(
        `‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ /start –¥–ª—è ${telegramId}: ${error.message}`,
        error.stack
      );
    }
  }

  private async sendWelcomeBackMessage(
    chatId: number,
    firstName: string
  ): Promise<void> {
    const message = `–ü—Ä–∏–≤–µ—Ç, ${firstName}! üëã\n\n–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –æ–±—Ä–∞—Ç–Ω–æ –≤ BotManager! –í–∞—à –∞–∫–∫–∞—É–Ω—Ç —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω –∏ –≥–æ—Ç–æ–≤ –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é.\n\n–î–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±–æ—Ç–∞–º–∏ –ø–µ—Ä–µ–π–¥–∏—Ç–µ –≤ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å: ${this.configService.get("app.frontendUrl")}`;

    this.logger.log(`üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é ${chatId}`);
    await this.sendMessage(chatId, message);
  }

  private async sendRegistrationInstructions(
    chatId: number,
    firstName: string,
    telegramId: string
  ): Promise<void> {
    const message = `–ü—Ä–∏–≤–µ—Ç, ${firstName}! üëã\n\n–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ BotManager! üöÄ\n\n–î–ª—è –Ω–∞—á–∞–ª–∞ —Ä–∞–±–æ—Ç—ã —Å –Ω–∞—à–∏–º —Å–µ—Ä–≤–∏—Å–æ–º –≤–∞–º –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è.\n\nüìã –í–∞—à Telegram ID: \`${telegramId}\`\n\nüîó –ü–µ—Ä–µ–π–¥–∏—Ç–µ –ø–æ —Å—Å—ã–ª–∫–µ –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏:\n${this.configService.get("app.frontendUrl")}/register\n\nüìù –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –ø–æ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏:\n1. –û—Ç–∫—Ä–æ–π—Ç–µ —Å—Å—ã–ª–∫—É –≤—ã—à–µ\n2. –í–≤–µ–¥–∏—Ç–µ –≤–∞—à Telegram ID: \`${telegramId}\`\n3. –ó–∞–ø–æ–ª–Ω–∏—Ç–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø–æ–ª—è\n4. –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é –∫–æ–¥–æ–º, –∫–æ—Ç–æ—Ä—ã–π –º—ã –æ—Ç–ø—Ä–∞–≤–∏–º\n\n–ü–æ—Å–ª–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –≤—ã —Å–º–æ–∂–µ—Ç–µ —Å–æ–∑–¥–∞–≤–∞—Ç—å –∏ —É–ø—Ä–∞–≤–ª—è—Ç—å Telegram –±–æ—Ç–∞–º–∏! ü§ñ`;

    this.logger.log(`üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é ${chatId}`);
    await this.sendMessage(chatId, message, { parse_mode: "Markdown" });
  }

  private async sendMessage(
    chatId: number,
    text: string,
    options?: { parse_mode?: "HTML" | "Markdown" | "MarkdownV2" }
  ): Promise<boolean> {
    if (!this.botToken) {
      this.logger.warn(
        `‚ö†Ô∏è –ù–µ—Ç —Ç–æ–∫–µ–Ω–∞ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è chatId: ${chatId}`
      );
      return false;
    }

    try {
      const url = `${this.getBotApiUrl()}/sendMessage`;
      this.logger.debug(`üåê POST ${url}`);

      const response = await axios.post(url, {
        chat_id: chatId,
        text,
        ...options,
      });

      if (response.data.ok) {
        this.logger.log(`‚úÖ –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ chatId: ${chatId}`);
        return true;
      } else {
        this.logger.error(
          `‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ chatId ${chatId}: ${response.data.description}`
        );
        return false;
      }
    } catch (error) {
      this.logger.error(
        `‚ùå –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ chatId ${chatId}: ${error.message}`,
        error.stack
      );
      if (error.response) {
        this.logger.error(
          `üìÑ Telegram API –æ—Ç–≤–µ—Ç: ${JSON.stringify(error.response.data)}`
        );
      }
      return false;
    }
  }

  // –ú–µ—Ç–æ–¥ –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ webhook (–≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è)
  async setupWebhook(): Promise<void> {
    if (!this.botToken) {
      this.logger.warn("TELEGRAM_BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω");
      throw new Error("TELEGRAM_BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω");
    }

    try {
      const webhookUrl = `${this.configService.get("app.webhookBaseUrl")}/assistant-bot/webhook`;
      const url = `${this.getBotApiUrl()}/setWebhook`;

      this.logger.log(`üîß –£—Å—Ç–∞–Ω–æ–≤–∫–∞ webhook: ${webhookUrl}`);

      const response = await axios.post(url, {
        url: webhookUrl,
        allowed_updates: ["message"],
      });

      if (response.data.ok) {
        this.logger.log("‚úÖ Webhook —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω —É—Å–ø–µ—à–Ω–æ");

        // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ webhook –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
        const webhookInfo = await this.getWebhookInfo();
        this.logger.log(`üìä Webhook info: ${JSON.stringify(webhookInfo)}`);
      } else {
        this.logger.error(
          `‚ùå –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ webhook: ${response.data.description}`
        );
      }
    } catch (error) {
      this.logger.error(
        `‚ùå –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ webhook: ${error.message}`,
        error.stack
      );
      throw error;
    }
  }

  async getWebhookInfo(): Promise<any> {
    if (!this.botToken) {
      throw new Error("TELEGRAM_BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω");
    }

    try {
      const url = `${this.getBotApiUrl()}/getWebhookInfo`;
      const response = await axios.get(url);

      if (response.data.ok) {
        return response.data.result;
      } else {
        throw new Error(`–û—à–∏–±–∫–∞ getWebhookInfo: ${response.data.description}`);
      }
    } catch (error) {
      this.logger.error(`–û—à–∏–±–∫–∞ getWebhookInfo: ${error.message}`);
      throw error;
    }
  }

  async deleteWebhook(): Promise<void> {
    if (!this.botToken) {
      throw new Error("TELEGRAM_BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω");
    }

    try {
      const url = `${this.getBotApiUrl()}/deleteWebhook`;
      const response = await axios.post(url);

      if (response.data.ok) {
        this.logger.log("‚úÖ Webhook —É–¥–∞–ª–µ–Ω");
      } else {
        this.logger.error(
          `‚ùå –û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è webhook: ${response.data.description}`
        );
      }
    } catch (error) {
      this.logger.error(`‚ùå –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ webhook: ${error.message}`);
      throw error;
    }
  }
}
