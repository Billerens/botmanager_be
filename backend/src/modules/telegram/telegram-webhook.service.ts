import { Injectable, Logger } from "@nestjs/common";
import { ConfigService } from "@nestjs/config";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import axios from "axios";

import { User } from "../../database/entities/user.entity";

export interface TelegramUpdate {
  update_id: number;
  message?: {
    message_id: number;
    from: {
      id: number;
      is_bot: boolean;
      first_name: string;
      last_name?: string;
      username?: string;
      language_code?: string;
    };
    chat: {
      id: number;
      first_name: string;
      last_name?: string;
      username?: string;
      type: string;
    };
    date: number;
    text?: string;
  };
}

@Injectable()
export class TelegramWebhookService {
  private readonly logger = new Logger(TelegramWebhookService.name);
  private readonly botToken: string;
  private readonly telegramApiUrl: string;

  constructor(
    private configService: ConfigService,
    @InjectRepository(User)
    private userRepository: Repository<User>
  ) {
    this.botToken = this.configService.get<string>("app.telegramBotToken");
    this.telegramApiUrl = this.configService.get<string>(
      "TELEGRAM_BOT_API_URL",
      "https://api.telegram.org/bot"
    );

    if (!this.botToken) {
      this.logger.error(
        "TELEGRAM_BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª Telegram webhook –±—É–¥–µ—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω."
      );
    } else {
      this.logger.log("‚úÖ TELEGRAM_BOT_TOKEN —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω");
    }
  }

  private getBotApiUrl(): string {
    return `${this.telegramApiUrl}${this.botToken}`;
  }

  async handleWebhook(update: TelegramUpdate): Promise<void> {
    try {
      this.logger.log(`üì© –ü–æ–ª—É—á–µ–Ω webhook: ${JSON.stringify(update)}`);

      if (update.message?.text) {
        await this.handleMessage(update.message);
      }
    } catch (error) {
      this.logger.error(`‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ webhook: ${error.message}`, error.stack);
    }
  }

  private async handleMessage(message: TelegramUpdate["message"]): Promise<void> {
    if (!message) return;

    const { text, from, chat } = message;
    const telegramId = from.id.toString();

    this.logger.log(`üì® –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç ${telegramId}: ${text}`);

    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–æ–º–∞–Ω–¥—É /start
    if (text === "/start") {
      this.logger.log(`üöÄ –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã /start –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${telegramId}`);
      await this.handleStartCommand(telegramId, from, chat);
    } else {
      this.logger.log(`‚ÑπÔ∏è –ü–æ–ª—É—á–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ, –Ω–æ —ç—Ç–æ –Ω–µ –∫–æ–º–∞–Ω–¥–∞ /start: ${text}`);
    }
  }

  private async handleStartCommand(
    telegramId: string,
    from: TelegramUpdate["message"]["from"],
    chat: TelegramUpdate["message"]["chat"]
  ): Promise<void> {
    try {
      this.logger.log(`üîç –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å telegramId: ${telegramId}`);
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
      const existingUser = await this.userRepository.findOne({
        where: { telegramId },
      });

      if (existingUser) {
        // –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω
        this.logger.log(`‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–π–¥–µ–Ω: ${existingUser.id}`);
        await this.sendWelcomeBackMessage(chat.id, from.first_name);
      } else {
        // –ù–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –ø–æ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
        this.logger.log(`üìù –ù–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å, –æ—Ç–ø—Ä–∞–≤–∫–∞ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π –ø–æ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏`);
        await this.sendRegistrationInstructions(chat.id, from.first_name, telegramId);
      }
    } catch (error) {
      this.logger.error(
        `‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–æ–º–∞–Ω–¥—ã /start –¥–ª—è ${telegramId}: ${error.message}`,
        error.stack
      );
    }
  }

  private async sendWelcomeBackMessage(chatId: number, firstName: string): Promise<void> {
    const message = `–ü—Ä–∏–≤–µ—Ç, ${firstName}! üëã\n\n–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –æ–±—Ä–∞—Ç–Ω–æ –≤ BotManager! –í–∞—à –∞–∫–∫–∞—É–Ω—Ç —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω –∏ –≥–æ—Ç–æ–≤ –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é.\n\n–î–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±–æ—Ç–∞–º–∏ –ø–µ—Ä–µ–π–¥–∏—Ç–µ –≤ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å: ${this.configService.get("app.frontendUrl")}`;

    this.logger.log(`üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é ${chatId}`);
    await this.sendMessage(chatId, message);
  }

  private async sendRegistrationInstructions(
    chatId: number,
    firstName: string,
    telegramId: string
  ): Promise<void> {
    const message = `–ü—Ä–∏–≤–µ—Ç, ${firstName}! üëã\n\n–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ BotManager! üöÄ\n\n–î–ª—è –Ω–∞—á–∞–ª–∞ —Ä–∞–±–æ—Ç—ã —Å –Ω–∞—à–∏–º —Å–µ—Ä–≤–∏—Å–æ–º –≤–∞–º –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è.\n\nüìã –í–∞—à Telegram ID: \`${telegramId}\`\n\nüîó –ü–µ—Ä–µ–π–¥–∏—Ç–µ –ø–æ —Å—Å—ã–ª–∫–µ –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏:\n${this.configService.get("app.frontendUrl")}/register\n\nüìù –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –ø–æ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏:\n1. –û—Ç–∫—Ä–æ–π—Ç–µ —Å—Å—ã–ª–∫—É –≤—ã—à–µ\n2. –í–≤–µ–¥–∏—Ç–µ –≤–∞—à Telegram ID: \`${telegramId}\`\n3. –ó–∞–ø–æ–ª–Ω–∏—Ç–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø–æ–ª—è\n4. –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é –∫–æ–¥–æ–º, –∫–æ—Ç–æ—Ä—ã–π –º—ã –æ—Ç–ø—Ä–∞–≤–∏–º\n\n–ü–æ—Å–ª–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –≤—ã —Å–º–æ–∂–µ—Ç–µ —Å–æ–∑–¥–∞–≤–∞—Ç—å –∏ —É–ø—Ä–∞–≤–ª—è—Ç—å Telegram –±–æ—Ç–∞–º–∏! ü§ñ`;

    this.logger.log(`üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π –ø–æ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é ${chatId}`);
    await this.sendMessage(chatId, message, { parse_mode: "Markdown" });
  }

  private async sendMessage(
    chatId: number,
    text: string,
    options?: { parse_mode?: "HTML" | "Markdown" | "MarkdownV2" }
  ): Promise<boolean> {
    if (!this.botToken) {
      this.logger.warn(
        `‚ö†Ô∏è –ü–æ–ø—ã—Ç–∫–∞ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –±–µ–∑ TELEGRAM_BOT_TOKEN –¥–ª—è chatId: ${chatId}`
      );
      return false;
    }

    try {
      const url = `${this.getBotApiUrl()}/sendMessage`;
      this.logger.debug(`üåê –û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –∫ Telegram API: ${url}`);
      this.logger.debug(`üí¨ –¢–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è: ${text.substring(0, 100)}...`);
      
      const response = await axios.post(url, {
        chat_id: chatId,
        text,
        ...options,
      });

      if (response.data.ok) {
        this.logger.log(`‚úÖ –°–æ–æ–±—â–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ Telegram –¥–ª—è chatId: ${chatId}`);
        return true;
      } else {
        this.logger.error(
          `‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ Telegram –¥–ª—è chatId ${chatId}: ${response.data.description}`
        );
        return false;
      }
    } catch (error) {
      this.logger.error(
        `‚ùå –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ Telegram –¥–ª—è chatId ${chatId}: ${error.message}`,
        error.stack
      );
      if (error.response) {
        this.logger.error(`üìÑ –û—Ç–≤–µ—Ç Telegram API: ${JSON.stringify(error.response.data)}`);
      }
      return false;
    }
  }

  // –ú–µ—Ç–æ–¥ –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ webhook (–≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è)
  async setWebhook(): Promise<void> {
    if (!this.botToken) {
      this.logger.warn(
        "TELEGRAM_BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, webhook –Ω–µ –±—É–¥–µ—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω"
      );
      throw new Error("TELEGRAM_BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω");
    }

    try {
      const webhookUrl = `${this.configService.get("app.webhookBaseUrl")}/api/telegram/webhook`;
      const url = `${this.getBotApiUrl()}/setWebhook`;

      this.logger.log(`üîß –£—Å—Ç–∞–Ω–æ–≤–∫–∞ webhook: ${webhookUrl}`);

      const response = await axios.post(url, {
        url: webhookUrl,
        allowed_updates: ["message"],
      });

      if (response.data.ok) {
        this.logger.log("‚úÖ Webhook —É—Å–ø–µ—à–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω");
        
        // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ webhook –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
        const webhookInfo = await this.getWebhookInfo();
        this.logger.log(`üìä –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ webhook: ${JSON.stringify(webhookInfo)}`);
      } else {
        this.logger.error(`‚ùå –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ webhook: ${response.data.description}`);
      }
    } catch (error) {
      this.logger.error(`‚ùå –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ webhook: ${error.message}`, error.stack);
      throw error;
    }
  }

  // –ú–µ—Ç–æ–¥ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ webhook
  async getWebhookInfo(): Promise<any> {
    if (!this.botToken) {
      throw new Error("TELEGRAM_BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω");
    }

    try {
      const url = `${this.getBotApiUrl()}/getWebhookInfo`;
      const response = await axios.get(url);

      if (response.data.ok) {
        return response.data.result;
      } else {
        throw new Error(
          `–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ webhook: ${response.data.description}`
        );
      }
    } catch (error) {
      this.logger.error(
        `–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ webhook: ${error.message}`
      );
      throw error;
    }
  }

  // –ú–µ—Ç–æ–¥ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è webhook (–¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è)
  async deleteWebhook(): Promise<void> {
    if (!this.botToken) {
      throw new Error("TELEGRAM_BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω");
    }

    try {
      const url = `${this.getBotApiUrl()}/deleteWebhook`;
      const response = await axios.post(url);

      if (response.data.ok) {
        this.logger.log("‚úÖ Webhook —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω");
      } else {
        this.logger.error(`‚ùå –û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è webhook: ${response.data.description}`);
      }
    } catch (error) {
      this.logger.error(`‚ùå –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ webhook: ${error.message}`);
      throw error;
    }
  }
}
